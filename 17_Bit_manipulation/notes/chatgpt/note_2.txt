Here is **Binary AND (&)** explained clearly with the example **5 & 6**.

---

# â­ **Binary AND (&) Operator**

**Definition:**
Binary AND compares each bit of two numbers.

Rule:

| Bit A | Bit B | A & B |
| ----- | ----- | ----- |
| 0     | 0     | 0     |
| 0     | 1     | 0     |
| 1     | 0     | 0     |
| 1     | 1     | 1     |

Only **1 & 1 = 1**
All other combinations give **0**.

---

# â­ **Example: 5 & 6**

First convert both numbers to **binary**:

```
5 = 0101
6 = 0110
```

Now perform AND **bit by bit**:

```
   0101   (5)
&  0110   (6)
---------
   0100
```

Binary **0100** = decimal **4**

---

# â­ **Final Answer**

```
5 & 6 = 4
```

---

# â­ **Java Code Example**

```java
public class Main {
    public static void main(String[] args) {
        int a = 5;
        int b = 6;
        int result = a & b;

        System.out.println("5 & 6 = " + result);  // Output: 4
    }
}
```

---

If you want, I can also give explanation for:

âœ” OR (|)
âœ” XOR (^)
âœ” NOT (~)
âœ” Left & Right shift

Just tell me!


Perfect! Here are **all bitwise operators** explained with **simple theory + examples + Java code** for each one.

---

# â­ **1. Binary AND (&)**

**Rule:**
Only **1 & 1 = 1**, all other â†’ 0

### Example: 5 & 6

```
5 = 0101
6 = 0110
---------
4 = 0100
```

### Java Code:

```java
int result = 5 & 6;
System.out.println(result); // 4
```

---

# â­ **2. Binary OR (|)**

**Rule:**
If **any bit is 1 â†’ result is 1**

### Example: 5 | 6

```
5 = 0101
6 = 0110
---------
7 = 0111
```

### Java Code:

```java
int result = 5 | 6;
System.out.println(result); // 7
```

---

# â­ **3. XOR (^)**

**Rule:**
Bits must be **different** to get **1**

| A | B | A^B |
| - | - | --- |
| 0 | 0 | 0   |
| 0 | 1 | 1   |
| 1 | 0 | 1   |
| 1 | 1 | 0   |

### Example: 5 ^ 6

```
5 = 0101
6 = 0110
---------
3 = 0011
```

### Java Code:

```java
int result = 5 ^ 6;
System.out.println(result); // 3
```

---

# â­ **4. NOT (~)**

Flips every bit.

### Example:

```
5 = 00000000 00000000 00000000 00000101
~5= 11111111 11111111 11111111 11111010
```

In Java, answer = **-6** (because Java uses 2â€™s complement).

### Java Code:

```java
int result = ~5;
System.out.println(result); // -6
```

---

# â­ **5. Left Shift (<<)**

Shifts bits **to left by n places**
Equivalent to: `number * 2^n`

### Example: 5 << 1

```
5 = 0101
<<1 = 1010 = 10
```

### Java Code:

```java
int result = 5 << 1;
System.out.println(result); // 10
```

---

# â­ **6. Right Shift (>>)**

Shifts bits **to right by n places**
Equivalent to: `number / 2^n`

### Example: 6 >> 1

```
6 = 0110
>>1 = 0011 = 3
```

### Java Code:

```java
int result = 6 >> 1;
System.out.println(result); // 3
```

---

# ğŸ‰ **Summary Table**

| Operator | Meaning     | Example (5,6) | Result |
| -------- | ----------- | ------------- | ------ |
| &        | AND         | 5 & 6         | **4**  |
| |        | OR          | 5 | 6         | **7**  |
| ^        | XOR         | 5 ^ 6         | **3**  |
| ~        | NOT         | ~5            | **-6** |
| <<       | Left Shift  | 5 << 1        | **10** |
| >>       | Right Shift | 6 >> 1        | **3**  |

---

If you want, I can also explain:

ğŸ”¹ Get ith bit
ğŸ”¹ Set ith bit
ğŸ”¹ Clear ith bit
ğŸ”¹ Update ith bit
ğŸ”¹ Count set bits
ğŸ”¹ Check power of 2
ğŸ”¹ Fast exponentiation

Just tell me which one!
