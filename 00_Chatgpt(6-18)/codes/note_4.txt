Here is **CODE + COMMENTS + OUTPUT + ALL SUB-POINT EXAMPLES**, exactly how you want.
Topic: **Functions / Methods in Java**

---

# âœ… **FUNCTIONS / METHODS IN JAVA â€“ FULL EXAMPLES**

We will cover:

1. Parameter vs Argument
2. What happens in memory
3. Call by value
4. Inbuilt vs User-defined functions
5. Function Overloading
6. Function Overriding

---

# ðŸŸ© **1. Parameter vs Argument**

ðŸ‘‰ **Parameters** = variables in the function definition
ðŸ‘‰ **Arguments** = values sent when calling the function

### âœ” Example

```java
public class ParamArgDemo {

    // parameters -> x and y
    static void add(int x, int y) {
        System.out.println("Sum = " + (x + y));
    }

    public static void main(String[] args) {

        // arguments -> 5 and 10
        add(5, 10);
    }
}
```

### **OUTPUT**

```
Sum = 15
```

---

# ðŸŸ© **2. What Happens in Memory (Call Stack)**

When a method is called:

1. A **new stack frame** is created
2. Parameters get **copied** inside stack frame
3. After the method finishes â†’ frame is removed

### âœ” Example to demonstrate

```java
public class MemoryDemo {

    static void show(int num) {
        System.out.println("Inside function, num = " + num);
    }

    public static void main(String[] args) {

        int num = 50;
        show(num);  // stack frame created and destroyed
    }
}
```

### **OUTPUT**

```
Inside function, num = 50
```

---

# ðŸŸ© **3. Call by Value (Java ALWAYS uses call by value)**

A **copy** of the variable is passed, original is NOT changed.

### âœ” Example

```java
public class CallByValueDemo {

    static void changeValue(int x) {
        x = 100; // changes only local copy
    }

    public static void main(String[] args) {

        int a = 20;
        changeValue(a);

        System.out.println("Value of a = " + a); // remains 20
    }
}
```

### **OUTPUT**

```
Value of a = 20
```

---

# ðŸŸ© **4. Inbuilt vs User-defined Functions**

### âœ” Inbuilt Function (Java Library)

`Math.sqrt()` is built-in.

```java
public class InbuiltDemo {
    public static void main(String[] args) {
        double ans = Math.sqrt(25); // inbuilt
        System.out.println(ans);
    }
}
```

### **OUTPUT**

```
5.0
```

---

### âœ” User-Defined Function

```java
public class UserDefinedDemo {

    static int square(int n) {
        return n * n;
    }

    public static void main(String[] args) {
        System.out.println(square(6));
    }
}
```

### **OUTPUT**

```
36
```

---

# ðŸŸ© **5. Function Overloading**

Same function name, **different parameters**.

```java
public class OverloadingDemo {

    // 1st version
    static void greet() {
        System.out.println("Hello!");
    }

    // 2nd version (different parameters)
    static void greet(String name) {
        System.out.println("Hello " + name);
    }

    public static void main(String[] args) {
        greet();
        greet("Prathmesh");
    }
}
```

### **OUTPUT**

```
Hello!
Hello Prathmesh
```

---

# ðŸŸ© **6. Function Overriding (Runtime Polymorphism)**

Same function name + same parameters
BUT in **different classes** using **inheritance**.

### âœ” Example

```java
class Animal {

    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {

    // overriding
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

public class OverrideDemo {
    public static void main(String[] args) {
        Animal obj = new Dog(); // parent reference, child object
        obj.sound();  // calls Dog's version
    }
}
```

### **OUTPUT**

```
Dog barks
```

---

# ðŸŽ‰ **DONE â€” All functions/methods subtopics with code + comments + output**

---

### ðŸ‘‰ Send next topic (arrays / OOP / recursion / patterns / operators etc.).

I will again give **code + comments + output for each subpoint**.
